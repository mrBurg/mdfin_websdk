import { EnrollmentProcessor, PhotoIDMatchProcessor } from '../processors';
import {
  TControllerProps,
  TLatestNetworkResponseStatus,
  TLatestProcessor,
  TProcessor,
  TStatus,
} from '../@types';
import {
  FaceTecIDScanResult,
  FaceTecSessionResult,
} from '../declarations/FaceTecPublicApi';
import { Config } from '../config/Config';
import { trace, $, /* logger, */ fetchData, triggerEvent } from '../../utils';
import { REQUEST_METHODS } from '../..';

export class Controller {
  private downtimeTimer: NodeJS.Timeout;
  latestEnrollmentIdentifier = '';
  latestSessionResult = null;
  latestIDScanResult = null;
  latestProcessor: TLatestProcessor;

  constructor(private cfg: Config, public controller: TControllerProps) {
    this.cfg.initializeFromAutogeneratedConfig((initializedSuccessfully) => {
      console.log(
        this.cfg.sdk.getFriendlyDescriptionForFaceTecSDKStatus(
          this.cfg.sdk.getStatus()
        )
      );

      if (initializedSuccessfully) {
        this.cfg.initLocalization();
        // AppUtilities.setVocalGuidanceSoundFiles();
        trace('FaceTecSDK initialized');

        switch (this.cfg.flow) {
          case 0:
            this.onEnrollUserPressed();

            break;

          case 1:
            this.onPhotoIDMatchPressed();

            break;
        }

        return;
      }

      this.statusUpload({
        id: this.cfg.sdk.getStatus(),
        name: this.cfg.sdk.FaceTecSDKStatus[this.cfg.sdk.getStatus()],
        class: 'SDKStatus',
      });
    });

    //logger('Controller initialized', controller);
  }

  async statusUpload(status: TStatus) {
    clearTimeout(this.downtimeTimer);

    try {
      await fetchData(this.cfg.paths.statusUpload, {
        /* headers: {
            Authorization: this.props.apiKey,
            'Content-Type': 'application/json',
          }, */
        method: REQUEST_METHODS.POST,
        body: JSON.stringify({
          operationId: this.cfg.id,
          status,
        }),
      });

      // if (this.cfg.cameraErrors.includes(status.name)) {
      // if (
      //   'mediaDevices' in navigator &&
      //   'getUserMedia' in navigator.mediaDevices
      // ) {
      //   /* const video = document.getElementById(
      //       'DOM_FT_videoElement'
      //     ) as HTMLVideoElement; */
      //   navigator.mediaDevices
      //     .getUserMedia({ video: true })
      //     .then(
      //       (stream) => {
      //         // console.log(video);
      //         /* if (video) {
      //             video.srcObject = stream;
      //             return video.srcObject;
      //           } */
      //         // console.log(stream);
      //         return stream;
      //       },
      //       (err) => console.log(err)
      //     )
      //     .catch((err) => console.log(err));
      // }

      // location.reload();

      // return;

      // this.controller.clearScript();
      // }

      this.controller.checkProcess();
    } catch (err) {
      this.controller.showError(err);
      this.downtime();
    }
  }

  private downtime = () => {
    clearTimeout(this.downtimeTimer);

    const closeWindow = () => {
      [
        '#DOM_FT_cancelButtonElement',
        '#DOM_FT_idScanCancelButtonElement',
        '#DOM_FT_cancelCustomButtonElement',
      ].forEach((item) => {
        const button = $(item);

        if (button) {
          [/* 'mouseover', */ 'mousedown' /* 'mouseup', 'click' */].forEach(
            (item) => triggerEvent(button, item)
          );
        } else {
          console.log('*** Target node not found!');
        }
      });
    };

    closeWindow();

    ['blur'].forEach((item) => triggerEvent(document, item));

    // setTimeout(() => closeWindow(), 1000);

    // $('#DOM_FT_PRIMARY_TOPLEVEL_mainContainer').remove();

    this.statusUpload({
      id: -1,
      name: 'Timeout',
      class: 'RecognID',
    });
  };

  reloadDowntime() {
    console.log('### DOWNTIME UPDATED ###');

    clearTimeout(this.downtimeTimer);

    this.downtimeTimer = setTimeout(this.downtime, this.cfg.downtime.value);
  }

  private startProcess(Processor: TProcessor) {
    // AppUtilities.fadeOutMainUIAndPrepareForSession();
    this.reloadDowntime();

    // document.addEventListener('mousemove', this.downtimeHandler);

    this.latestEnrollmentIdentifier = this.cfg.id;
    this.latestProcessor = new Processor(this.cfg, this);

    //logger('startProcess', Processor);
  }

  onEnrollUserPressed() {
    this.startProcess(EnrollmentProcessor);
  }

  onPhotoIDMatchPressed() {
    this.startProcess(PhotoIDMatchProcessor);
  }

  onVocalGuidanceSettingsButtonPressed() {
    trace('onVocalGuidanceSettingsButtonPressed');

    // AppUtilities.setVocalGuidanceMode();
  }

  async onViewAuditTrailPressed() {
    // Last changes
    /* if (this.cfg.paths.auditTrailPath) {
      return Router.push(this.cfg.paths.auditTrailPath);
    } */

    trace('Audit trail path not found');

    // AppUtilities.showAuditTrailImages(latestSessionResult, latestIDScanResult);
  }

  onComplete(
    sessionResult: FaceTecSessionResult,
    idScanResult: FaceTecIDScanResult,
    latestNetworkResponseStatus: TLatestNetworkResponseStatus
  ) {
    this.latestSessionResult = sessionResult;
    this.latestIDScanResult = idScanResult;

    let currentStatus = this.latestSessionResult.status;

    if (this.latestIDScanResult) {
      currentStatus = this.latestIDScanResult.status;
    }

    if (currentStatus) {
      this.statusUpload({
        id: currentStatus,
        name: this.cfg.sdk.FaceTecSessionStatus[currentStatus],
        class: 'SessionStatus',
      });
    }

    // showAdditionalScreensServerIsDown();

    if (this.latestProcessor.isSuccess()) {
      // AppUtilities.displayStatus('Success');
    } else {
      if (
        this.isNetworkResponseServerIsOffline(latestNetworkResponseStatus) ===
        true
      ) {
        // this.showAdditionalScreensServerIsDown();

        return;
      }
    }

    // AppUtilities.showMainUI();
  }

  clearLatestEnrollmentIdentifier() {
    this.latestEnrollmentIdentifier = '';
  }

  isNetworkResponseServerIsOffline(networkResponseStatus: number) {
    return networkResponseStatus >= 500;
  }

  onServerSessionTokenError() {
    trace('onServerSessionTokenError');

    // AppUtilities.handleErrorGettingServerSessionToken();
  }

  showAdditionalScreensServerIsDown() {
    trace('showAdditionalScreensServerIsDown');

    // AdditionalScreens.showServerUpGradeView();
  }
}
